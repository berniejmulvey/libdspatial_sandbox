---
title: "chapters8-11"
author: "Bernie Mulvey"
date: "2023-04-19"
output: html_document
---

```{r setup, include=FALSE}
library(data.table)
library(SpatialExperiment)
library(ggspavis)
library(scater) # addPerCellQC
# library(STexampleData)
```

## look at components of an spe obj
```{r}
spe <- Visium_humanDLPFC()
# eh i kinda would prefer to look at something with multiple samples
# rm(spe)
# unloadNamespace(STexampleData)

library(WeberDivechaLCdata)
## oh lord have to update R and bioconductor and everything bbl
```

# OK let's see what a dataset (multiple samples) looks like.
```{r}
splc <- WeberDivechaLCdata_Visium()
dim(splc)
head(colData(splc))
tail(colData(splc))
# ah ok so there's just columns for each sample strung together.
```

### Ch9: QC / filtering
1. Is the tissue oriented correctly?
```{r}
ggspavis::plotSpots(splc)
# well, these are all distinct sections, so that's a good enough start

# we would do this to get rid of non-tissue spots, but that's already been done here. let's double check that there's no non-tissue spots remaining though
sum(colData(splc)$in_tissue != 1, na.rm = T)
# qed

dim(splc)
# and which is why we have a number of spots (20380) not divisible by 8
```

2. Mitochondrial reads--which were actually not used as a filter for the LC data so we can actually apply this step. Get a vector of features and whether or not they're mitochondrial
```{r}
# data.table derived style (won't work)
# mitogenes <- rowData(splc[rowData(splc)$gene_name %in% grep(rowData(splc)$gene_name,pattern="MT-|mt-",value=T)])$gene_name

# also WONT work-vector of gene names to include
mitogenesymbs <- grep(rowData(splc)$gene_name, pattern = "MT-|mt-", value = T)


## these WILL work:
# 1. full-length vector of T/F for matching MT-.*
mitogenes <- rowData(splc)$gene_name %in% grep(rowData(splc)$gene_name, pattern = "MT-|mt-", value = T)

# 2. as coded in the tutorial
is_mito <- grepl("(^MT-)|(^mt-)", rowData(splc)$gene_name)
rowData(splc)$gene_name[is_mito]
```


#### now the next step, totalling reads per spot might need a vector of length nrow to work. let's find out.
```{r}
# working from the t/f vector for matching "MT-" (mitogenes)
splc2 <- addPerCellQC(splc, subsets = list(Mito = mitogenes))
# as expected

# as coded in tutorial
splc3 <- addPerCellQC(splc, subsets = list(mito = is_mito))


stopifnot(sum(mitogenes == is_mito) == length(mitogenes))
# ^ approaches are equiv.

# splc4 <- addPerCellQC(splc,subsets=list(Mito=mitogenesymbs))
# THAT doesn't work though--expects indices
rm(splc3, splc4, mitogenesymbs, is_mito)


# these data now are in our coldata ('sample'/'cell' data)
colData(splc2)$subsets_Mito_percent
sum(colData(splc2)$subsets_Mito_percent > 20)
# ouch. let's call our cutoff 50%.
colData(splc2)$excessmito <- colData(splc2)$subsets_Mito_percent>50
```

plot some qc stats
### coldata()$sum represents # of UMIs per spot
### standard threshold is 600 UMIs
```{r}
ggplot(as.data.frame(colData(splc))[which(as.data.frame(colData(splc))$sum<10000),], aes(x = sum)) +
    geom_histogram(binwidth = 100)+
  geom_vline(xintercept = 600,col="red")
dev.off()
# again, ouch
```

### also look at sum PER # cells per spot. using ggspavis::plotQC. set threshold_y to the value we might plan to use--this function will draw on a horiz line to show what would be getting clipped off

### oh, LC data doesn't have this (but those values would usually be there from VistoSeg)
### we'll throw in some random values based on the dlpfc tutorial and just not actually filter on them at the end.
```{r}
# plotQC(splc,type = "scatter",metric_x = "cell_count",metric_y ="sum",threshold_y = 600)
# splc@colData$cell_count <- sample(x=c(1:7),size=nrow(splc@colData),replace = T)
# hist(colData(splc)$cell_count,breaks = 20)

###  der no we want a neg binom? gamma? dist for these fake values
coldat.tmp <- as.data.table(colData(splc2))
# coldat.tmp[,cell_count:=]
# n = number of spots per sample
coldat.tmp[, cell_count := sample(
    ceiling(rgamma(nrow(.SD),shape = 3,scale=2)),
    size = nrow(.SD), replace = T
), .SDcols = "sample_id"]

hist(coldat.tmp$cell_count,breaks = 20)
dev.off()
### ok that looks decently like the dlpfc data. (not that this is really true for LC)

colData(splc2) <- DataFrame(coldat.tmp)
```

# so anyhow, we would look at counts per spot as a function of cells per spot like this
```{r}
plotQC(splc2,type = "scatter",metric_x = "cell_count",metric_y ="sum",threshold_y = 600)

# as before, if we wanted to flag spots with more than 10 cells for exclusion (e.g., if that seems to be where the number of genes per spot dives off), then we add a new column to coldata as T/F:
colData(splc2)$overtencells <- colData(splc2)$cell_count>10
```

### now, let's visually check that these spots with >10 cells are not all in one area of their tissue sections (which would indicate something biology-y happening)
```{r}
plotSpots(splc2,annotate = "overtencells")
# and our randomlly generated values are randomly assorted. v good v good. so if this is what real cell count data looked like, we'd be ok to eventually throw those spots
```

### 9.5.2: filtering for number of genes detected (coldata(spe)$detected)
```{r}
# again, we want a histogram and then a plotqc to examine the # cells relationship
hist(colData(splc2)$detected)
# let's look first, then plot again with some estimated threshold out a threshold estimate
plotQC(splc2,type = "scatter",metric_y= "detected",metric_x = "cell_count")
# sine there are ~0 gene-detected spots across the (fake) cell count let's try  1750 and see what that trendline looks like
dtct1750 <- colData(splc2)$detected<1750
colData(splc2)$dtct1750 <- dtct1750 
splc3 <- splc2[,dtct1750==F]
# naw, naw let's try 200
dtct200 <- colData(splc2)$detected<200
colData(splc2)$dtct200 <- dtct200
### make a temporary spe object with only the hypothetically remaining data to see what the outcome would be 
splc3 <- splc2[,dtct200==F]
plotQC(splc3,type = "scatter",metric_y= "detected",metric_x = "cell_count",threshold_y = 200)

# visualize to check for (biological) spatial pattern
plotSpots(splc2,annotate = "dtct200")
## looks like this partially tracks with ventricles? (e.g. 2701 right hand piece) but otherwise tissue edges, which would not represent anything biological here.
rm(splc3)
```

# we worked out of order and already did mitochondrial reads. so
```{r}
colSums(as.data.frame(colData(splc2)[,c("dtct200","excessmito","overtencells")]))
# so 9822 dropped for low gene detection, 3088 dropped for mitochondria, and 2535 hypothetically dropped for too many cells

toss <- dtct200 | colData(splc2)$excessmito
splc2 <- splc2[,toss==F]
# what's left?
dim(splc2)
# about 48% of the data.

```


###################
###### CH 10 ######
###################

### we will be continuing with scater as well as scran functions to apply library-size normalized, LOG COUNT normalization AFTER filtering the data.
```{r}
library(scran)
splc2 <- computeLibraryFactors(splc2)
# peek
summary(sizeFactors(splc2))
hist(sizeFactors(splc2),breaks=100)
saveRDS(splc2,"splc2_line192.RDS")
# append log counts using scater (don't use the SpatialExpt:: function here, that's for RETRIEVING an assay by the name of "logcounts" from spe objs)
splc2 <- scater::logNormCounts(splc2)
# this is stored as a separate DF the ASSAYS component of the SpatialExpt obj
names(splc2@assays)
stopifnot(dim(counts(splc2))==dim(logcounts(splc2)))
# o this was easy chap
rm(toss,mitogenes,dtct200,dtct1750)
gc(full=T)
dev.off()
```

###################
###### CH 11 ######
###################